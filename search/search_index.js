var __index = {"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"<code>nmrlineshapeanalyser</code>: ss-NMR peak shape deconvolution and line shape analysis made easy","text":"<p><code>nmrlineshapeanalyser</code> is an open-source Python package designed to make peak deconvolution or line shape analysis in 1D NMR spectrum easier.</p> <p>This package is compatible with Bruker's NMR data and spectrum data saved in a CSV files (see User's guide).</p>"},{"location":"index.html#why-nmrlineshapeanalyser","title":"Why <code>nmrlineshapeanalyser</code>?","text":"<ul> <li>it offers an easy and fast processing of either lineshape spectral analysis or peak deconvolution</li> <li>it requires the path to processed Bruker's data <code>data\\single_peak\\10\\pdata\\1</code> </li> <li>for the optimisation, you only need to input the peak position(s) -- it does the rest</li> <li>it gives you the freedom to decide if you want to either optimise or fix the peak peak position(s) while other peak parameters are refined</li> <li>it provides you a detailed analysis of the optimised Pseudo-Voigt parameters that describe your peak(s) -- saved in a txt file</li> <li>for peak deconvolution, it calculates the percentage of each peaks </li> <li>it saves fit and data in a CSV file in case you decide to visualise in your preferred software</li> <li>it saves your fit as a publication-quality png file </li> </ul>"},{"location":"index.html#key-features","title":"Key Features","text":"<ul> <li>Load and process Bruker NMR data</li> <li>Select and analyse specific spectral regions</li> <li>Perform peak fitting using Pseudo-Voigt profiles</li> <li>Calculate detailed peak metrics and statistics</li> <li>Generate publication-quality visuals</li> <li>Export results in various formats:<ul> <li>txt: calculated peak metrics and statistics</li> <li>png: visualisation of the fitted spectral regions</li> <li>csv: save plots to a file</li> </ul> </li> </ul>"},{"location":"index.html#install","title":"Install","text":"<pre><code>pip install nmrlineshapeanalyser\n</code></pre>"},{"location":"index.html#dependencies","title":"Dependencies","text":"<p>The following packages are required:</p> <pre><code>nmrglue \nnumpy &gt;= 1.26.0\nscipy \nmatplotlib &gt;= 3.9.0\npandas &gt;= 2.2.0\n</code></pre> <p>You can install these dependencies using pip:</p> <pre><code>pip install nmrglue numpy&gt;=1.26.0 scipy matplotlib&gt;=3.9.0 pandas&gt;=2.2.0\n</code></pre>"},{"location":"index.html#a-single-peak-fitting-example","title":"A Single Peak Fitting Example","text":"<p><pre><code>from nmrlineshapeanalyser.core import NMRProcessor\n\n#create NMRProcessor object\n\nprocessor = NMRProcessor()\n\n#Load filepath: always include the '\\\\'\nfilepath = r\"..\\data\\single_peak\\10\\pdata\\1\\\\\"\n\n# Load the data\n\nprocessor.load_data(filepath)\n\n#Select the region of interest\n\nx_data, y_data = processor.select_region(512, 650)\n\n#Normalize the data and return normalised y_axis and the corresponding x_axis\n\nx_data, y_normalized = processor.normalize_data(x_data, y_data)\n\n#define initial parameters for the fitting\n#this example is for a single peak\n#format of the parameters is [x0, amplitude, width, eta, offset]\n# x0 (position), amplitude, width, eta (mixing parameter), offset\n#x0 has to be close to the peak position\n\n\ninitial_params = [\n581, 0.12, 40.51, 0.89, -143.115, \n  ]\n\n#Specify the number of peaks to be fitted\n\nnumber_of_peaks = 1\n\n# fixed_x0 controls whether peak positions should be fixed during fitting\n# False means position can vary, True means position is fixed\nfixed_x0 = [False] * number_of_peaks\n\n# You can alternatively set it up as:\n\n#fixed_x0 = [False] \n\n#Where the number of False reflects the number of peaks you want to optimise \n# i.e. [False, False] means you want to optimise two peak positions and so on\n\n#FIt the data\npopt, metrics, fitted = processor.fit_peaks(x_data, y_normalized, initial_params, fixed_x0)\n\n#popt is the optimized parameters\n#metrics is the metrics of the fitting\n#fitted is the fitted curve data\n\n#Plot and examine the results of the fitting\nfig, axes, components = processor.plot_results(x_data, y_normalized, fitted, popt)\n\n#Save the figure as a png file and the results as a csv file\nprocessor.save_results(filepath, x_data, y_normalized, fitted, metrics, popt, components)\n</code></pre> This should generate the image below.</p> <p></p> <p>And a cell looking like:</p> <pre><code>Peak Fitting Results:\n===================\n\nPeak 1 (Position: 582.01 \u00b1 0.01):\nAmplitude: 0.993 \u00b1 0.002\nWidth: 12.33 \u00b1 0.03 in ppm\nWidth: 835.74 \u00b1 2.36 in Hz\nEta: 1.00 \u00b1 0.01\nOffset: -0.004 \u00b1 0.000\nGaussian Area: 0.00 \u00b1 0.10\nLorentzian Area: 19.23 \u00b1 0.16\nTotal Area: 19.23 \u00b1 0.19\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 1.39%\nOverall Percentage is 100.00% \u00b1 1.39%\n</code></pre>"},{"location":"index.html#contact","title":"Contact","text":"<p>For questions and support, please open an issue in the GitHub repository.</p>"},{"location":"about/Changelog.html","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/Changelog.html#added","title":"Added","text":"<ul> <li>load_csv function to load spectrum data saved in a CSV file</li> <li>an example on how to fit spectrum data saved in a CSV file</li> <li>an example on batch processing several spectra for Hendrickson-Bray model for motional narrowing in solids</li> </ul>"},{"location":"about/Contributors.html","title":"People","text":"<p>nmrlineshapeanalyser is written by Abdulkadir Olatunbosun Biffo.</p>"},{"location":"about/Contributors.html#active-maintainers","title":"Active Maintainers","text":"<p>The current maintainer is Abdulkadir Olatunbosun Biffo.</p>"},{"location":"about/Contributors.html#inspiration","title":"Inspiration","text":"<p>On a cold morning while enduring the usual Dutch weather, I had a conversation with my PhD supervisor Pedro Braga Groszewicz about deconvoluting Lorentzian and Gaussian areas from a complex 1D 17O MAS ss-NMR spectrum. He explained the concept of Voigt and Pseudo-Voigt functions and how they could help with this deconvolution. He mentioned MestreNova software, which indeed offered a solution to my problem. However, I was not just interested in the solution but also the black box behind it.</p> <p>So I embarked on a journey to unravel this black box and didn't stop until I discovered how it worked. This journey led to the creation of this package.</p>"},{"location":"about/Contributors.html#credits","title":"Credits","text":"<p>I would like to thank the creator NMRglue for making it possible to work directly with Bruker's folder. Also, a special thanks to the creator(s) of LMFit's built-in models -- their content was pivotal in understanding the concept of the Pseudo-Voigt function and its parameters. A special shoutout to [matplotlib] (https://matplotlib.org/) and scipy.</p>"},{"location":"about/License.html","title":"License","text":"<p>MIT License</p> <p>Copyright \u00a9 2024</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"installation/install.html","title":"Installation","text":"<p>If you have Python and pip installed, you can install <code>nmrlineshapeanalyser</code> with the command below:</p> <pre><code>pip install nmrlineshapeanalyser\n</code></pre> <p>All dependencies in <code>pyproject.toml</code> file are automatically installed</p> <p>To verify that the package has been installed, run the command below in a Python console</p> <pre><code>import nmrlineshapeanalyser\n</code></pre>"},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>nmrlineshapeanalyser<ul> <li>core</li> </ul> </li> </ul>"},{"location":"reference/nmrlineshapeanalyser/core.html","title":"core","text":""},{"location":"reference/nmrlineshapeanalyser/core.html#nmrlineshapeanalyser.core","title":"nmrlineshapeanalyser.core","text":""},{"location":"reference/nmrlineshapeanalyser/core.html#nmrlineshapeanalyser.core.NMRProcessor","title":"NMRProcessor","text":"<pre><code>NMRProcessor()\n</code></pre> <p>A comprehensive processor for Nuclear Magnetic Resonance (NMR) spectroscopic data.</p> <pre><code>This class provides functionality for loading, processing, and analyzing NMR data, specifically:\n- Loading and processing Bruker format NMR data\n- Selecting and normalizing specific spectral regions\n- Fitting multiple peaks using Pseudo-Voigt functions\n- Calculating peak parameters and error estimates\n- Visualizing results with publication-quality plots\n- Exporting analysis results in multiple formats\n\nAttributes:\n    data (np.ndarray): Raw NMR spectral data\n    number (str): Atomic mass number of probe Nucleus\n    nucleus (str): Probe Nucleus (e.g., 'H', 'C', 'N')\n    uc (ng.unit_conversion): Unit conversion object for frequency/ppm\n    ppm (np.ndarray): Chemical shift scale in PPM\n    ppm_limits (tuple): Range of chemical shifts in dataset\n    fixed_params (list): Parameters fixed during fitting\n    larmor_freq (float): Larmor frequency in MHz\n</code></pre> <p>Sets up default plot styling and initializes class attributes to None. Plot styling is configured for publication-quality figures.</p> Source code in <code>src/nmrlineshapeanalyser/core.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initialize the NMR processor with default settings.\n\n    Sets up default plot styling and initializes class attributes to None.\n    Plot styling is configured for publication-quality figures.\n\n    \"\"\"\n    self.data = None\n    self.number = None\n    self.nucleus = None\n    self.uc = None\n    self.ppm = None\n    self.ppm_limits = None\n    self.fixed_params = None\n    self.larmor_freq = None\n    self.set_plot_style()\n</code></pre>"},{"location":"reference/nmrlineshapeanalyser/core.html#nmrlineshapeanalyser.core.NMRProcessor.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data = None\n</code></pre>"},{"location":"reference/nmrlineshapeanalyser/core.html#nmrlineshapeanalyser.core.NMRProcessor.fixed_params","title":"fixed_params  <code>instance-attribute</code>","text":"<pre><code>fixed_params = None\n</code></pre>"},{"location":"reference/nmrlineshapeanalyser/core.html#nmrlineshapeanalyser.core.NMRProcessor.larmor_freq","title":"larmor_freq  <code>instance-attribute</code>","text":"<pre><code>larmor_freq = None\n</code></pre>"},{"location":"reference/nmrlineshapeanalyser/core.html#nmrlineshapeanalyser.core.NMRProcessor.nucleus","title":"nucleus  <code>instance-attribute</code>","text":"<pre><code>nucleus = None\n</code></pre>"},{"location":"reference/nmrlineshapeanalyser/core.html#nmrlineshapeanalyser.core.NMRProcessor.number","title":"number  <code>instance-attribute</code>","text":"<pre><code>number = None\n</code></pre>"},{"location":"reference/nmrlineshapeanalyser/core.html#nmrlineshapeanalyser.core.NMRProcessor.ppm","title":"ppm  <code>instance-attribute</code>","text":"<pre><code>ppm = None\n</code></pre>"},{"location":"reference/nmrlineshapeanalyser/core.html#nmrlineshapeanalyser.core.NMRProcessor.ppm_limits","title":"ppm_limits  <code>instance-attribute</code>","text":"<pre><code>ppm_limits = None\n</code></pre>"},{"location":"reference/nmrlineshapeanalyser/core.html#nmrlineshapeanalyser.core.NMRProcessor.uc","title":"uc  <code>instance-attribute</code>","text":"<pre><code>uc = None\n</code></pre>"},{"location":"reference/nmrlineshapeanalyser/core.html#nmrlineshapeanalyser.core.NMRProcessor.calculate_peak_metrics","title":"calculate_peak_metrics","text":"<pre><code>calculate_peak_metrics(popt, pcov, fixed_x0)\n</code></pre> <p>Calculate comprehensive metrics for each fitted peak.</p> <p>Computes peak parameters and their uncertainties, including: - Peak position, amplitude, width - Gaussian and Lorentzian areas - Total peak area - Error estimates for all parameters</p> <p>Args:     popt (np.ndarray): Optimized parameters     pcov (np.ndarray): Covariance matrix from fitting     fixed_x0 (List[bool]): Which peak positions were fixed</p> <p>Returns:     List[Dict]: Metrics for each peak including error estimates</p> <p>Note:     Error estimates are calculated using error propagation from the     covariance matrix</p> Source code in <code>src/nmrlineshapeanalyser/core.py</code> <pre><code>def calculate_peak_metrics(self, popt: np.ndarray, pcov: np.ndarray, \n                         fixed_x0: List[bool]) -&gt; List[Dict]:\n\n    \"\"\"\n\n    Calculate comprehensive metrics for each fitted peak.\n\n    Computes peak parameters and their uncertainties, including:\n    - Peak position, amplitude, width\n    - Gaussian and Lorentzian areas\n    - Total peak area\n    - Error estimates for all parameters\n\n    Args:\n        popt (np.ndarray): Optimized parameters\n        pcov (np.ndarray): Covariance matrix from fitting\n        fixed_x0 (List[bool]): Which peak positions were fixed\n\n    Returns:\n        List[Dict]: Metrics for each peak including error estimates\n\n    Note:\n        Error estimates are calculated using error propagation from the\n        covariance matrix\n\n    \"\"\"\n    n_peaks = len(popt) // 5\n    peak_results = []\n    errors = np.sqrt(np.diag(pcov)) if pcov.size else np.zeros_like(popt)\n    error_idx = 0\n\n    for i in range(n_peaks):\n        # Extract parameters for current peak\n        x0, amp, width, eta, offset = popt[5*i:5*(i+1)]\n\n        # Calculate errors based on whether x0 was fixed\n        if fixed_x0[i]:\n            x0_err = 0\n            amp_err, width_err, eta_err, offset_err = errors[error_idx:error_idx + 4]\n            error_idx += 4\n        else:\n            x0_err, amp_err, width_err, eta_err, offset_err = errors[error_idx:error_idx + 5]\n            error_idx += 5\n\n        # Calculate areas and their errors\n        sigma = width / (2 * np.sqrt(2 * np.log(2)))\n        gamma = width / 2\n\n        gauss_area = (1 - eta) * amp * sigma * np.sqrt(2 * np.pi)\n        lorentz_area = eta * amp * np.pi * gamma\n        total_area = gauss_area + lorentz_area\n\n        # Calculate error propagation\n        gauss_area_err = np.sqrt(\n            ((1 - eta) * sigma * np.sqrt(2 * np.pi) * amp_err) ** 2 +\n            (amp * sigma * np.sqrt(2 * np.pi) * eta_err) ** 2 +\n            ((1 - eta) * amp * np.sqrt(2 * np.pi) * (width_err / (2 * np.sqrt(2 * np.log(2))))) ** 2\n        )\n\n        lorentz_area_err = np.sqrt(\n            (eta * np.pi * gamma * amp_err) ** 2 +\n            (amp * np.pi * gamma * eta_err) ** 2 +\n            (eta * amp * np.pi * (width_err / 2)) ** 2\n        )\n\n        total_area_err = np.sqrt(gauss_area_err ** 2 + lorentz_area_err ** 2)\n\n        # Store results\n        peak_results.append({\n            'x0': (x0, x0_err),\n            'amplitude': (amp, amp_err),\n            'width': (width, width_err),\n            'eta': (eta, eta_err),\n            'offset': (offset, offset_err),\n            'gaussian_area': (gauss_area, gauss_area_err),\n            'lorentzian_area': (lorentz_area, lorentz_area_err),\n            'total_area': (total_area, total_area_err)\n        })\n\n    return peak_results\n</code></pre>"},{"location":"reference/nmrlineshapeanalyser/core.html#nmrlineshapeanalyser.core.NMRProcessor.fit_peaks","title":"fit_peaks","text":"<pre><code>fit_peaks(x_data, y_data, initial_params, fixed_x0=None)\n</code></pre> <p>Fit multiple Pseudo-Voigt peaks to the spectral data.</p> <p>Performs non-linear least squares fitting using scipy.optimize.curve_fit. Supports fixing peak positions and provides error estimates from the covariance matrix.</p> <p>Args:     x_data (np.ndarray): X-axis data     y_data (np.ndarray): Y-axis data     initial_params (List[float]): Initial parameters for all peaks     fixed_x0 (Optional[List[bool]]): Which peak positions to fix during fitting</p> <p>Returns:     tuple: Containing:         - np.ndarray: Optimized parameters         - List[Dict]: Peak metrics including errors         - np.ndarray: Fitted data</p> <p>Raises:     ValueError: If number of parameters is incorrect</p> <p>Note:     For each peak, parameters must be provided in order:     [x0, amplitude, width, eta, offset]</p> Source code in <code>src/nmrlineshapeanalyser/core.py</code> <pre><code>def fit_peaks(self, x_data: np.ndarray, y_data: np.ndarray, \n             initial_params: List[float], fixed_x0: Optional[List[bool]] = None) -&gt; Tuple[np.ndarray, List[Dict], np.ndarray]:\n    \"\"\"\n    Fit multiple Pseudo-Voigt peaks to the spectral data.\n\n    Performs non-linear least squares fitting using scipy.optimize.curve_fit.\n    Supports fixing peak positions and provides error estimates from the\n    covariance matrix.\n\n    Args:\n        x_data (np.ndarray): X-axis data\n        y_data (np.ndarray): Y-axis data\n        initial_params (List[float]): Initial parameters for all peaks\n        fixed_x0 (Optional[List[bool]]): Which peak positions to fix during fitting\n\n    Returns:\n        tuple: Containing:\n            - np.ndarray: Optimized parameters\n            - List[Dict]: Peak metrics including errors\n            - np.ndarray: Fitted data\n\n    Raises:\n        ValueError: If number of parameters is incorrect\n\n    Note:\n        For each peak, parameters must be provided in order:\n        [x0, amplitude, width, eta, offset]\n    \"\"\"\n    # Input validation\n    if len(initial_params) % 5 != 0:\n        raise ValueError(\"Number of initial parameters must be divisible by 5\")\n\n    if fixed_x0 is None:\n        fixed_x0 = [False] * (len(initial_params) // 5)\n\n    # Setup for fitting\n    n_peaks = len(initial_params) // 5\n    self.fixed_params = []\n    fit_params = []\n    lower_bounds = []\n    upper_bounds = []\n\n    # Process each peak's parameters\n    for i in range(n_peaks):\n        x0, amp, width, eta, offset = initial_params[5*i:5*(i+1)]\n\n        if fixed_x0[i]:\n            self.fixed_params.append((x0, None, None, None, None))\n            fit_params.extend([amp, width, eta, offset])\n            lower_bounds.extend([0, 1, 0, -np.inf])\n            upper_bounds.extend([np.inf, np.inf, 1, np.inf])\n        else:\n            self.fixed_params.append((None, None, None, None, None))\n            fit_params.extend([x0, amp, width, eta, offset])\n            lower_bounds.extend([x0 - width/2, 0, 1, 0, -np.inf])\n            upper_bounds.extend([x0 + width/2, np.inf, np.inf, 1, np.inf])\n\n    # Perform the fit\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore', category=RuntimeWarning)\n        popt, pcov = curve_fit(self.pseudo_voigt_multiple, x_data, y_data,\n                             p0=fit_params, bounds=(lower_bounds, upper_bounds),\n                             maxfev=10000, method='trf')\n\n    # Process results\n    full_popt = self._process_fit_results(popt, initial_params, fixed_x0)\n    peak_metrics = self.calculate_peak_metrics(full_popt, pcov, fixed_x0)\n    fitted_data = self.pseudo_voigt_multiple(x_data, *popt)\n\n    return full_popt, peak_metrics, fitted_data\n</code></pre>"},{"location":"reference/nmrlineshapeanalyser/core.html#nmrlineshapeanalyser.core.NMRProcessor.load_csv","title":"load_csv","text":"<pre><code>load_csv(filepath, atomic_no, nucleus, larmor_freq)\n</code></pre> <p>Load CSV data exported from MNova.</p> <p>Args:     filepath (str): Directory path containing the CSV file     atomic_no (str): Atomic number of the nucleus     nucleus (str): Nuclear symbol     larmor_freq (float): Larmor frequency in MHz</p> <p>Raises:     FileNotFoundError: If no CSV files are found in the specified directory</p> Source code in <code>src/nmrlineshapeanalyser/core.py</code> <pre><code>def load_csv(self, filepath: str, atomic_no: str, nucleus: str, larmor_freq: float) -&gt; None:\n    \"\"\"\n    Load CSV data exported from MNova.\n\n    Args:\n        filepath (str): Directory path containing the CSV file\n        atomic_no (str): Atomic number of the nucleus\n        nucleus (str): Nuclear symbol\n        larmor_freq (float): Larmor frequency in MHz\n\n    Raises:\n        FileNotFoundError: If no CSV files are found in the specified directory\n    \"\"\"\n    # Use proper path joining for the glob pattern\n    csv_files = glob.glob(os.path.join(filepath, '*.csv'))\n\n    if not csv_files:\n        raise FileNotFoundError(f\"No CSV files found in {filepath}\")\n\n    # Load the CSV file found \n    data = pd.read_csv(csv_files[0])\n\n    # Verify required columns exist\n    required_columns = ['ppm', 'Intensity']\n    if not all(col in data.columns for col in required_columns):\n        raise ValueError(f\"CSV must contain columns: {required_columns}\")\n\n    # Extract data\n    x_data = data['ppm'].values\n    y_data = data['Intensity'].values\n\n    # Create pseudo-complex data\n    y_data = y_data + 1j * np.zeros_like(y_data)\n\n    # Store data in class attributes\n    self.ppm = x_data\n    self.data = y_data\n    self.number = str(atomic_no)  # Ensure atomic_no is stored as string\n    self.nucleus = nucleus\n    self.larmor_freq = float(larmor_freq)  # Ensure larmor_freq is stored as float\n</code></pre>"},{"location":"reference/nmrlineshapeanalyser/core.html#nmrlineshapeanalyser.core.NMRProcessor.load_data","title":"load_data","text":"<pre><code>load_data(filepath)\n</code></pre> <p>Load and process Bruker format NMR data.</p> <p>Args:     filepath (str): Path to the Bruker data directory containing processed data</p> <p>Raises:     FileNotFoundError: If the specified filepath does not exist     ValueError: If the data cannot be properly loaded or processed</p> <p>Note:     This method extracts key spectral parameters including:     - Nuclear species and spin quantum number     - Larmor frequency in MHz     - Chemical shift scale in PPM</p> Source code in <code>src/nmrlineshapeanalyser/core.py</code> <pre><code>def load_data(self, filepath: str) -&gt; None:\n    \"\"\"\n    Load and process Bruker format NMR data.\n\n    Args:\n        filepath (str): Path to the Bruker data directory containing processed data\n\n    Raises:\n        FileNotFoundError: If the specified filepath does not exist\n        ValueError: If the data cannot be properly loaded or processed\n\n    Note:\n        This method extracts key spectral parameters including:\n        - Nuclear species and spin quantum number\n        - Larmor frequency in MHz\n        - Chemical shift scale in PPM\n    \"\"\"\n    # Read the Bruker data\n    dic, self.data = ng.bruker.read_pdata(filepath)\n\n    # Set the spectral parameters\n    udic = ng.bruker.guess_udic(dic, self.data)\n    nuclei = udic[0]['label']\n\n    obs = udic[0]['obs']\n\n    self.larmor_freq = obs\n    # Extract number and nucleus symbols\n    self.number = ''.join(filter(str.isdigit, nuclei))\n    self.nucleus = ''.join(filter(str.isalpha, nuclei))\n\n    # Create converter and get scales\n    self.uc = ng.fileiobase.uc_from_udic(udic, dim=0)\n    self.ppm = self.uc.ppm_scale()\n    self.ppm_limits = self.uc.ppm_limits()\n</code></pre>"},{"location":"reference/nmrlineshapeanalyser/core.html#nmrlineshapeanalyser.core.NMRProcessor.normalize_data","title":"normalize_data","text":"<pre><code>normalize_data(x_data, y_data)\n</code></pre> <p>Normalize spectral data for processing.</p> <p>Performs baseline correction and amplitude normalization:  1. Subtracts minimum value (baseline correction)  2. Divides by maximum value (amplitude normalization)</p> <p>Args:      x_data (np.ndarray): X-axis data (chemical shift)      y_data (np.ndarray): Y-axis data (signal intensity)</p> <p>Returns:      tuple: Containing:          - np.ndarray: Original x-axis data          - np.ndarray: Normalized y-axis data</p> <p>Note:      X-axis data is returned unchanged; only y-axis data is normalized</p> Source code in <code>src/nmrlineshapeanalyser/core.py</code> <pre><code>def normalize_data(self, x_data: np.ndarray, y_data: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n   Normalize spectral data for processing.\n\n    Performs baseline correction and amplitude normalization:\n    1. Subtracts minimum value (baseline correction)\n    2. Divides by maximum value (amplitude normalization)\n\n    Args:\n        x_data (np.ndarray): X-axis data (chemical shift)\n        y_data (np.ndarray): Y-axis data (signal intensity)\n\n    Returns:\n        tuple: Containing:\n            - np.ndarray: Original x-axis data\n            - np.ndarray: Normalized y-axis data\n\n    Note:\n        X-axis data is returned unchanged; only y-axis data is normalized\n    \"\"\"\n    # Convert to float type to avoid integer division issues\n    y_data = y_data.astype(float)\n    y_ground = np.min(y_data)\n    y_normalized = y_data - y_ground\n    y_amp = np.max(y_normalized)\n\n\n    # Handle the case where all values are the same (y_amp would be 0)\n    if y_amp != 0:\n        y_normalized /= y_amp\n\n    return x_data, y_normalized\n</code></pre>"},{"location":"reference/nmrlineshapeanalyser/core.html#nmrlineshapeanalyser.core.NMRProcessor.plot_results","title":"plot_results","text":"<pre><code>plot_results(x_data, y_data, fitted_data, popt)\n</code></pre> <p>Create publication-quality visualization of fitting results.</p> <pre><code>    Generates a plot showing:\n    - Original data points\n    - Overall fitted curve\n    - Individual peak components\n    - Residuals between data and fit\n    - Peak positions marked\n\n    Args:\n        x_data (np.ndarray): X-axis data\n        y_data (np.ndarray): Y-axis data\n        fitted_data (np.ndarray): Fitted curve data\n        popt (np.ndarray): Optimized parameters\n\n    Returns:\n        tuple: Containing:\n            - plt.Figure: Figure object\n            - plt.Axes: Axes object\n            - List[np.ndarray]: Individual peak components\n\n    Note:\n</code></pre> <p>Plot styling is controlled by set_plot_style() method</p> Source code in <code>src/nmrlineshapeanalyser/core.py</code> <pre><code>def plot_results(self, x_data: np.ndarray, y_data: np.ndarray, \n                fitted_data: np.ndarray,\n                popt: np.ndarray) -&gt; Tuple[plt.Figure, plt.Axes, List[np.ndarray]]:\n    \"\"\"\n        Create publication-quality visualization of fitting results.\n\n                Generates a plot showing:\n                - Original data points\n                - Overall fitted curve\n                - Individual peak components\n                - Residuals between data and fit\n                - Peak positions marked\n\n                Args:\n                    x_data (np.ndarray): X-axis data\n                    y_data (np.ndarray): Y-axis data\n                    fitted_data (np.ndarray): Fitted curve data\n                    popt (np.ndarray): Optimized parameters\n\n                Returns:\n                    tuple: Containing:\n                        - plt.Figure: Figure object\n                        - plt.Axes: Axes object\n                        - List[np.ndarray]: Individual peak components\n\n                Note:\n        Plot styling is controlled by set_plot_style() method\n    \"\"\"\n    fig, ax1 = plt.subplots(1, 1, figsize=(12, 10))\n\n    # Plot normalized data\n    ax1.plot(x_data, y_data, 'ok', ms=1, label='Data')\n    ax1.plot(x_data, fitted_data, '-r', lw=2, label='Fit')\n    residuals = y_data - fitted_data\n    ax1.plot(x_data, residuals-0.05, '-g', lw=2, label='Residuals', alpha=0.5)\n\n    # Plot components\n    n_peaks = len(popt) // 5\n    components = []\n\n    for i in range(n_peaks):\n        x0, amp, width, eta, offset = popt[5*i:5*(i+1)]\n        component = self.pseudo_voigt(x_data, x0, amp, width, eta)\n        components.append(component)\n\n        ax1.fill(x_data, component, alpha=0.5, label=f'Component {i+1}')\n        ax1.plot(x0, self.pseudo_voigt(np.array([x0]), x0, amp, width, eta), \n                'ob', label='Peak Position' if i == 0 else None)\n\n    ax1.invert_xaxis()\n    ax1.legend(ncol=2, fontsize=10)\n    ax1.set_title('Normalized Scale')\n    ax1.set_xlabel(f'$^{{{self.number}}} \\\\ {self.nucleus}$ chemical shift  (ppm)')\n    ax1.hlines(0, x_data[0], x_data[-1], colors='blue', linestyles='dashed', alpha=0.5)\n\n    plt.tight_layout()\n\n    return fig, ax1, components\n</code></pre>"},{"location":"reference/nmrlineshapeanalyser/core.html#nmrlineshapeanalyser.core.NMRProcessor.pseudo_voigt","title":"pseudo_voigt  <code>staticmethod</code>","text":"<pre><code>pseudo_voigt(x, x0, amp, width, eta)\n</code></pre> <p>Calculate the Pseudo-Voigt function, a linear combination of Gaussian and Lorentzian profiles.</p> <p>The Pseudo-Voigt function is defined as:</p> <p>\u03b7 * L(x) + (1-\u03b7) * G(x)</p> <p>where L(x) is the Lorentzian component and G(x) is the Gaussian component</p> <p>Args:     x (np.ndarray): X-axis values     x0 (float): Peak center position     amp (float): Peak amplitude     width (float): Peak width (FWHM)     eta (float): Mixing parameter (0 for pure Gaussian, 1 for pure Lorentzian)</p> <p>Returns:     np.ndarray: Calculated Pseudo-Voigt values</p> <p>Note:     FWHM (Full Width at Half Maximum) is the same for both Gaussian and      Lorentzian components</p> <pre><code>       sigma = width / (2 * np.sqrt(2 * np.log(2)))\n       gamma = width / 2\n       lorentzian = amp * (gamma**2 / ((x - x0)**2 + gamma**2))\n       gaussian = amp * np.exp(-0.5 * ((x - x0) / sigma)**2)\n</code></pre> Source code in <code>src/nmrlineshapeanalyser/core.py</code> <pre><code>@staticmethod\ndef pseudo_voigt(x: np.ndarray, x0: float, amp: float, width: float, eta: float) -&gt; np.ndarray:\n\n    \"\"\"\n    Calculate the Pseudo-Voigt function, a linear combination of Gaussian and Lorentzian profiles.\n\n    The Pseudo-Voigt function is defined as:\n\n    \u03b7 * L(x) + (1-\u03b7) * G(x)\n\n    where L(x) is the Lorentzian component and G(x) is the Gaussian component\n\n    Args:\n        x (np.ndarray): X-axis values\n        x0 (float): Peak center position\n        amp (float): Peak amplitude\n        width (float): Peak width (FWHM)\n        eta (float): Mixing parameter (0 for pure Gaussian, 1 for pure Lorentzian)\n\n    Returns:\n        np.ndarray: Calculated Pseudo-Voigt values\n\n    Note:\n        FWHM (Full Width at Half Maximum) is the same for both Gaussian and \n        Lorentzian components\n\n               sigma = width / (2 * np.sqrt(2 * np.log(2)))\n               gamma = width / 2\n               lorentzian = amp * (gamma**2 / ((x - x0)**2 + gamma**2))\n               gaussian = amp * np.exp(-0.5 * ((x - x0) / sigma)**2)\n    \"\"\"\n    sigma = width / (2 * np.sqrt(2 * np.log(2)))\n    gamma = width / 2\n    lorentzian = amp * (gamma**2 / ((x - x0)**2 + gamma**2))\n    gaussian = amp * np.exp(-0.5 * ((x - x0) / sigma)**2)\n    return eta * lorentzian + (1 - eta) * gaussian\n</code></pre>"},{"location":"reference/nmrlineshapeanalyser/core.html#nmrlineshapeanalyser.core.NMRProcessor.pseudo_voigt_multiple","title":"pseudo_voigt_multiple","text":"<pre><code>pseudo_voigt_multiple(x, *params)\n</code></pre> <p>Calculate multiple Pseudo-Voigt peaks.</p> <p>Args:     x (np.ndarray): X-axis values     *params: Variable number of peak parameters</p> <p>Returns:     np.ndarray: Sum of all Pseudo-Voigt peaks</p> Source code in <code>src/nmrlineshapeanalyser/core.py</code> <pre><code>def pseudo_voigt_multiple(self, x: np.ndarray, *params) -&gt; np.ndarray:\n    \"\"\"\n    Calculate multiple Pseudo-Voigt peaks.\n\n    Args:\n        x (np.ndarray): X-axis values\n        *params: Variable number of peak parameters\n\n    Returns:\n        np.ndarray: Sum of all Pseudo-Voigt peaks\n    \"\"\"\n    n_peaks = len(self.fixed_params)\n    param_idx = 0\n    y = np.zeros_like(x)\n\n    for i in range(n_peaks):\n        if self.fixed_params[i][0] is not None:\n            x0 = self.fixed_params[i][0]\n            amp, width, eta, offset = params[param_idx:param_idx + 4]\n            param_idx += 4\n        else:\n            x0, amp, width, eta, offset = params[param_idx:param_idx + 5]\n            param_idx += 5\n\n        y += self.pseudo_voigt(x, x0, amp, width, eta) + offset\n\n    return y\n</code></pre>"},{"location":"reference/nmrlineshapeanalyser/core.html#nmrlineshapeanalyser.core.NMRProcessor.save_results","title":"save_results","text":"<pre><code>save_results(filepath, x_data, y_data, fitted_data, peak_metrics, popt, components)\n</code></pre> <p>Save all analysis results to files.</p> <pre><code>    Creates three output files:\n    1. CSV file with peak data and components\n    2. Text file with detailed metrics\n    3. PNG file with visualization plot\n\n    Args:\n        filepath (str): Base path for saving files\n        x_data (np.ndarray): X-axis data\n        y_data (np.ndarray): Y-axis data\n        fitted_data (np.ndarray): Fitted curve data\n        peak_metrics (List[Dict]): Peak metrics including errors\n        popt (np.ndarray): Optimized parameters\n        components (List[np.ndarray]): Individual peak components\n\n    Note:\n        Files are named automatically based on the base filepath:\n        - peak_data.csv\n        - pseudoVoigtPeak_metrics.txt\n        - pseudoVoigtPeakFit.png\n</code></pre> Source code in <code>src/nmrlineshapeanalyser/core.py</code> <pre><code>def save_results(self, filepath: str, x_data: np.ndarray, y_data: np.ndarray,\n                fitted_data: np.ndarray, peak_metrics: List[Dict],\n                popt: np.ndarray, components: List[np.ndarray]) -&gt; None:\n    \"\"\"\n        Save all analysis results to files.\n\n                Creates three output files:\n                1. CSV file with peak data and components\n                2. Text file with detailed metrics\n                3. PNG file with visualization plot\n\n                Args:\n                    filepath (str): Base path for saving files\n                    x_data (np.ndarray): X-axis data\n                    y_data (np.ndarray): Y-axis data\n                    fitted_data (np.ndarray): Fitted curve data\n                    peak_metrics (List[Dict]): Peak metrics including errors\n                    popt (np.ndarray): Optimized parameters\n                    components (List[np.ndarray]): Individual peak components\n\n                Note:\n                    Files are named automatically based on the base filepath:\n                    - peak_data.csv\n                    - pseudoVoigtPeak_metrics.txt\n                    - pseudoVoigtPeakFit.png\n    \"\"\"\n    self._save_peak_data(filepath, x_data, y_data, fitted_data, components)\n    self._save_metrics(filepath, peak_metrics)\n    self._save_plot(filepath, x_data, y_data, fitted_data,\n                   popt)\n    self._print_detailed_results(peak_metrics)\n</code></pre>"},{"location":"reference/nmrlineshapeanalyser/core.html#nmrlineshapeanalyser.core.NMRProcessor.select_region","title":"select_region","text":"<pre><code>select_region(ppm_start, ppm_end)\n</code></pre> <p>Select a specific region of the NMR spectrum for analysis.</p> <p>Args:     ppm_start (float): Starting chemical shift value in PPM     ppm_end (float): Ending chemical shift value in PPM</p> <p>Returns:     tuple: Containing:         - np.ndarray: X-axis data (chemical shift in PPM)         - np.ndarray: Y-axis data (signal intensity)</p> <p>Raises:     ValueError: If no data is loaded or selected region is outside data range</p> <p>Note:     The selected region is inclusive of both start and end points</p> Source code in <code>src/nmrlineshapeanalyser/core.py</code> <pre><code>def select_region(self, ppm_start: float, ppm_end: float) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Select a specific region of the NMR spectrum for analysis.\n\n    Args:\n        ppm_start (float): Starting chemical shift value in PPM\n        ppm_end (float): Ending chemical shift value in PPM\n\n    Returns:\n        tuple: Containing:\n            - np.ndarray: X-axis data (chemical shift in PPM)\n            - np.ndarray: Y-axis data (signal intensity)\n\n    Raises:\n        ValueError: If no data is loaded or selected region is outside data range\n\n    Note:\n        The selected region is inclusive of both start and end points\n    \"\"\"\n    if self.data is None:\n        raise ValueError(\"No data loaded. Call load_data first.\")\n\n    if ppm_start &gt; np.max(self.ppm) or ppm_end &lt; np.min(self.ppm):\n        raise ValueError(f\"Selected region ({ppm_start}, {ppm_end}) is outside \"\n                    f\"data range ({np.min(self.ppm)}, {np.max(self.ppm)})\")\n\n    region_mask = (self.ppm &gt;= ppm_start) &amp; (self.ppm &lt;= ppm_end)\n    x_region = self.ppm[region_mask]\n    y_real = self.data.real\n    y_region = y_real[region_mask]\n\n    return x_region, y_region\n</code></pre>"},{"location":"reference/nmrlineshapeanalyser/core.html#nmrlineshapeanalyser.core.NMRProcessor.set_plot_style","title":"set_plot_style  <code>staticmethod</code>","text":"<pre><code>set_plot_style()\n</code></pre> <p>Configure matplotlib plotting parameters for consistent, publication-quality figures.</p> <p>Sets font family, sizes, tick parameters, and line widths to create professional-looking plots suitable for publication.</p> Source code in <code>src/nmrlineshapeanalyser/core.py</code> <pre><code>@staticmethod\ndef set_plot_style() -&gt; None:\n    \"\"\"\n        Configure matplotlib plotting parameters for consistent, publication-quality figures.\n\n        Sets font family, sizes, tick parameters, and line widths to create\n        professional-looking plots suitable for publication.\n    \"\"\"\n    mpl.rcParams['font.family'] = \"sans-serif\"\n    plt.rcParams['font.sans-serif'] = ['Arial']\n    plt.rcParams['font.size'] = 14\n    plt.rcParams['axes.linewidth'] = 2\n    mpl.rcParams['xtick.major.size'] = mpl.rcParams['ytick.major.size'] = 8\n    mpl.rcParams['xtick.major.width'] = mpl.rcParams['ytick.major.width'] = 1\n    mpl.rcParams['xtick.direction'] = mpl.rcParams['ytick.direction'] = 'out'\n    mpl.rcParams['xtick.major.top'] = mpl.rcParams['ytick.major.right'] = False\n    mpl.rcParams['xtick.minor.size'] = mpl.rcParams['ytick.minor.size'] = 5\n    mpl.rcParams['xtick.minor.width'] = mpl.rcParams['ytick.minor.width'] = 1\n    mpl.rcParams['xtick.top'] = mpl.rcParams['ytick.right'] = True\n</code></pre>"},{"location":"user_guide/example_of_2_peaks.html","title":"Example of 2 peaks","text":"<pre><code>import sys\nimport matplotlib.pyplot as plt\nsys.path.append(\"../../src\")\nfrom nmrlineshapeanalyser.core import NMRProcessor\n\n#create NMRProcessor object\n\nprocessor = NMRProcessor()\n\n#Load filepath\nfilepath = r\"..\\..\\data\\two_peaks\\2\\pdata\\1\"\n\n\n# Load the data\n\nprocessor.load_data(filepath)\n\n#Select the region of interest\n\nx_data, y_data = processor.select_region(-630, -540)\n\n#Normalize the data and return normalised y_axis and the corresponding x_axis\n\nx_data, y_normalized = processor.normalize_data(x_data, y_data)\n\n#define initial parameters for the fitting\n#this example is for a single peak\n#format of the parameters is [x0, amplitude, width, eta, offset]\n# x0 (position), amplitude, width, eta (mixing parameter), offset\n#x0 has to be close to the peak position\ninitial_params = [\n                  -576.4, 0.12, 40.51, 0.89, -143.115, \n                  -597, 0.12, 40.51, 0.89, -143.115\n                  ]\n\nnumber_of_peaks = 2\n# fixed_x0 controls whether peak positions should be fixed during fitting\n# False means position can vary, True means position is fixed\n\nfixed_x0 = [False]*number_of_peaks\n\n#alternatively as:\n\n# fixed_x0 = [False, False]\n\n\n#FIt the data\npopt, metrics, fitted = processor.fit_peaks(x_data, y_normalized, initial_params, fixed_x0)\n\n#popt is the optimized parameters\n#metrics is the metrics of the fitting\n#fitted is the fitted curve data\n\n#Plot and examine the results of the fitting\nfig, axes, components = processor.plot_results(x_data, y_normalized, fitted, popt)\n\n#Save the figure as an png file and the results as a csv file\nprocessor.save_results(filepath, x_data, y_normalized, fitted, metrics, popt, components)\n</code></pre> <pre>\n<code>\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -576.83 \u00b1 0.02):\nAmplitude: 0.996 \u00b1 0.002\nWidth: 13.97 \u00b1 0.04 in ppm\nWidth: 1838.20 \u00b1 4.97 in Hz\nEta: 0.22 \u00b1 0.01\nOffset: 208.596 \u00b1 994425.596\nGaussian Area: 11.58 \u00b1 0.19\nLorentzian Area: 4.77 \u00b1 0.28\nTotal Area: 16.35 \u00b1 0.34\n--------------------------------------------------\n\nPeak 2 (Position: -595.46 \u00b1 0.04):\nAmplitude: 0.396 \u00b1 0.002\nWidth: 15.50 \u00b1 0.09 in ppm\nWidth: 2038.93 \u00b1 12.48 in Hz\nEta: 0.00 \u00b1 0.03\nOffset: -208.599 \u00b1 994425.596\nGaussian Area: 6.53 \u00b1 0.21\nLorentzian Area: 0.00 \u00b1 0.31\nTotal Area: 6.53 \u00b1 0.38\n--------------------------------------------------\nPeak 1 Percentage is 71.44% \u00b1 2.15%\nPeak 2 Percentage is 28.56% \u00b1 1.76%\nOverall Percentage is 100.00% \u00b1 2.78%\n</code>\n</pre>"},{"location":"user_guide/example_of_6_peaks.html","title":"Example of 6 peaks","text":"<pre><code>import sys\nimport matplotlib.pyplot as plt\nsys.path.append(\"../../src\")\nfrom nmrlineshapeanalyser.core import NMRProcessor\n\n#create NMRProcessor object\n\nprocessor = NMRProcessor()\n\n#Load filepath\nfilepath = r\"..\\..\\data\\six_peaks\\5\\pdata\\1\\\\\"\n\n\n# Load the data\n\nprocessor.load_data(filepath)\n\n#Select the region of interest\n\nx_data, y_data = processor.select_region(200, 800)\n\n#Normalize the data and return normalised y_axis and the corresponding x_axis\n\nx_data, y_normalized = processor.normalize_data(x_data, y_data)\n\n#define initial parameters for the fitting\n#this example is for a single peak\n#format of the parameters is [x0, amplitude, width, eta, offset]\n# x0 (position), amplitude, width, eta (mixing parameter), offset\n#x0 has to be close to the peak position\ninitial_params = [\n                  334, 0.12, 40.51, 0.89, -143.115, \n                  430, 0.12, 40.51, 0.89, -143.115,\n                  497, 0.219, 55.43, 0.52, -143.115,\n                  562, 0.12, 40.51, 0.89, -143.115,\n                  581, 0.219, 55.43, 0.52, -143.155,\n                  623, 0.12, 40.51, 0.89, -143.115\n                  ]\n\nnumber_of_peaks = 6\n# fixed_x0 controls whether peak positions should be fixed during fitting\n# False means position can vary, True means position is fixed\nfixed_x0 = [False]*number_of_peaks\n\n#FIt the data\npopt, metrics, fitted = processor.fit_peaks(x_data, y_normalized, initial_params, fixed_x0)\n\n#popt is the optimized parameters\n#metrics is the metrics of the fitting\n#fitted is the fitted curve data\n\n#Plot and examine the results of the fitting\nfig, axes, components = processor.plot_results(x_data, y_normalized, fitted, popt)\n\n#Save the figure as an png file and the results as a csv file\nprocessor.save_results(filepath, x_data, y_normalized, fitted, metrics, popt, components)\n</code></pre> <pre>\n<code>\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: 335.07 \u00b1 0.19):\nAmplitude: 0.060 \u00b1 0.001\nWidth: 47.42 \u00b1 0.55 in ppm\nWidth: 3215.12 \u00b1 36.98 in Hz\nEta: 0.00 \u00b1 0.06\nOffset: -965.720 \u00b1 13452.906\nGaussian Area: 3.04 \u00b1 0.19\nLorentzian Area: 0.00 \u00b1 0.27\nTotal Area: 3.04 \u00b1 0.33\n--------------------------------------------------\n\nPeak 2 (Position: 431.23 \u00b1 0.19):\nAmplitude: 0.225 \u00b1 0.004\nWidth: 57.32 \u00b1 0.60 in ppm\nWidth: 3886.79 \u00b1 40.92 in Hz\nEta: 0.48 \u00b1 0.02\nOffset: -178.649 \u00b1 2760.662\nGaussian Area: 7.08 \u00b1 0.34\nLorentzian Area: 9.80 \u00b1 0.50\nTotal Area: 16.88 \u00b1 0.61\n--------------------------------------------------\n\nPeak 3 (Position: 497.39 \u00b1 0.25):\nAmplitude: 0.135 \u00b1 0.017\nWidth: 38.41 \u00b1 1.91 in ppm\nWidth: 2604.37 \u00b1 129.64 in Hz\nEta: 0.35 \u00b1 0.08\nOffset: 1880.891 \u00b1 3039.696\nGaussian Area: 3.61 \u00b1 0.67\nLorentzian Area: 2.83 \u00b1 0.78\nTotal Area: 6.44 \u00b1 1.03\n--------------------------------------------------\n\nPeak 4 (Position: 580.16 \u00b1 0.46):\nAmplitude: 0.095 \u00b1 0.020\nWidth: 31.00 \u00b1 2.67 in ppm\nWidth: 2101.75 \u00b1 180.90 in Hz\nEta: 0.36 \u00b1 0.19\nOffset: -327.977 \u00b1 3039.696\nGaussian Area: 2.02 \u00b1 0.75\nLorentzian Area: 1.65 \u00b1 0.95\nTotal Area: 3.67 \u00b1 1.21\n--------------------------------------------------\n\nPeak 5 (Position: 553.29 \u00b1 1.75):\nAmplitude: 0.642 \u00b1 0.026\nWidth: 72.26 \u00b1 2.27 in ppm\nWidth: 4899.37 \u00b1 153.92 in Hz\nEta: 0.00 \u00b1 0.13\nOffset: -333.249 \u00b1 3039.696\nGaussian Area: 49.40 \u00b1 6.84\nLorentzian Area: 0.00 \u00b1 9.37\nTotal Area: 49.40 \u00b1 11.60\n--------------------------------------------------\n\nPeak 6 (Position: 614.38 \u00b1 1.31):\nAmplitude: 0.724 \u00b1 0.019\nWidth: 83.87 \u00b1 1.04 in ppm\nWidth: 5686.87 \u00b1 70.58 in Hz\nEta: 0.00 \u00b1 0.03\nOffset: -75.293 \u00b1 3039.697\nGaussian Area: 64.62 \u00b1 2.86\nLorentzian Area: 0.05 \u00b1 3.18\nTotal Area: 64.67 \u00b1 4.27\n--------------------------------------------------\nPeak 1 Percentage is 2.11% \u00b1 0.29%\nPeak 2 Percentage is 11.71% \u00b1 1.10%\nPeak 3 Percentage is 4.47% \u00b1 0.81%\nPeak 4 Percentage is 2.54% \u00b1 0.87%\nPeak 5 Percentage is 34.29% \u00b1 8.58%\nPeak 6 Percentage is 44.88% \u00b1 4.89%\nOverall Percentage is 100.00% \u00b1 10.01%\n</code>\n</pre>"},{"location":"user_guide/example_of_6_peaks_versII.html","title":"example of 6 peaks versII","text":"<pre><code>import sys\nimport matplotlib.pyplot as plt\nsys.path.append(\"../../src\")\nfrom nmrlineshapeanalyser.core import NMRProcessor\n\n#create NMRProcessor object\n\nprocessor = NMRProcessor()\n\n#Load filepath\nfilepath = r\"..\\..\\data\\six_peaks\\4\\pdata\\1\\\\\"\n\n\n# Load the data\n\nprocessor.load_data(filepath)\n\n#Select the region of interest\n\nx_data, y_data = processor.select_region(200, 800)\n\n#Normalize the data and return normalised y_axis and the corresponding x_axis\n\nx_data, y_normalized = processor.normalize_data(x_data, y_data)\n\n#define initial parameters for the fitting\n#this example is for a single peak\n#format of the parameters is [x0, amplitude, width, eta, offset]\n# x0 (position), amplitude, width, eta (mixing parameter), offset\n#x0 has to be close to the peak position\ninitial_params = [\n                  380, 0.12, 40.51, 0.89, -143.115, \n                  425, 0.12, 40.51, 0.89, -143.115,\n                  500, 0.219, 55.43, 0.52, -143.115,\n                  547, 0.12, 40.51, 0.89, -143.115,\n                  586, 0.219, 55.43, 0.52, -143.155,\n                  647, 0.12, 40.51, 0.89, -143.115\n                  ]\n\nnumber_of_peaks = 6\n# fixed_x0 controls whether peak positions should be fixed during fitting\n# False means position can vary, True means position is fixed\nfixed_x0 = [False]*number_of_peaks\n\n#FIt the data\npopt, metrics, fitted = processor.fit_peaks(x_data, y_normalized, initial_params, fixed_x0)\n\n#popt is the optimized parameters\n#metrics is the metrics of the fitting\n#fitted is the fitted curve data\n\n#Plot and examine the results of the fitting\nfig, axes, components = processor.plot_results(x_data, y_normalized, fitted, popt)\n\n#Save the figure as an png file and the results as a csv file\nprocessor.save_results(filepath, x_data, y_normalized, fitted, metrics, popt, components)\n</code></pre> <pre>\n<code>\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: 380.13 \u00b1 0.13):\nAmplitude: 0.812 \u00b1 0.018\nWidth: 26.50 \u00b1 0.23 in ppm\nWidth: 1796.58 \u00b1 15.93 in Hz\nEta: 0.39 \u00b1 0.03\nOffset: -66633.772 \u00b1 0.000\nGaussian Area: 13.88 \u00b1 0.80\nLorentzian Area: 13.31 \u00b1 1.12\nTotal Area: 27.19 \u00b1 1.38\n--------------------------------------------------\n\nPeak 2 (Position: 404.75 \u00b1 3.30):\nAmplitude: 0.094 \u00b1 0.006\nWidth: 41.61 \u00b1 4.87 in ppm\nWidth: 2821.63 \u00b1 330.08 in Hz\nEta: 0.00 \u00b1 0.26\nOffset: 30009.056 \u00b1 0.000\nGaussian Area: 4.18 \u00b1 1.24\nLorentzian Area: 0.00 \u00b1 1.63\nTotal Area: 4.18 \u00b1 2.05\n--------------------------------------------------\n\nPeak 3 (Position: 501.22 \u00b1 0.07):\nAmplitude: 0.504 \u00b1 0.003\nWidth: 25.93 \u00b1 0.18 in ppm\nWidth: 1757.99 \u00b1 12.03 in Hz\nEta: 0.00 \u00b1 0.04\nOffset: 33328.037 \u00b1 0.000\nGaussian Area: 13.90 \u00b1 0.57\nLorentzian Area: 0.00 \u00b1 0.81\nTotal Area: 13.90 \u00b1 0.99\n--------------------------------------------------\n\nPeak 4 (Position: 547.42 \u00b1 0.03):\nAmplitude: 0.954 \u00b1 0.004\nWidth: 23.56 \u00b1 0.09 in ppm\nWidth: 1597.33 \u00b1 5.92 in Hz\nEta: 0.02 \u00b1 0.03\nOffset: 10056.373 \u00b1 0.000\nGaussian Area: 23.50 \u00b1 0.74\nLorentzian Area: 0.64 \u00b1 1.07\nTotal Area: 24.14 \u00b1 1.30\n--------------------------------------------------\n\nPeak 5 (Position: 588.24 \u00b1 0.05):\nAmplitude: 0.781 \u00b1 0.003\nWidth: 29.54 \u00b1 0.16 in ppm\nWidth: 2002.97 \u00b1 10.66 in Hz\nEta: 0.45 \u00b1 0.03\nOffset: -21085.163 \u00b1 0.000\nGaussian Area: 13.51 \u00b1 0.65\nLorentzian Area: 16.29 \u00b1 0.95\nTotal Area: 29.80 \u00b1 1.15\n--------------------------------------------------\n\nPeak 6 (Position: 650.20 \u00b1 0.24):\nAmplitude: 0.122 \u00b1 0.003\nWidth: 27.34 \u00b1 0.62 in ppm\nWidth: 1854.04 \u00b1 42.10 in Hz\nEta: 0.00 \u00b1 0.12\nOffset: 14325.466 \u00b1 0.000\nGaussian Area: 3.56 \u00b1 0.43\nLorentzian Area: 0.00 \u00b1 0.61\nTotal Area: 3.56 \u00b1 0.74\n--------------------------------------------------\nPeak 1 Percentage is 26.46% \u00b1 1.58%\nPeak 2 Percentage is 4.07% \u00b1 2.00%\nPeak 3 Percentage is 13.52% \u00b1 1.06%\nPeak 4 Percentage is 23.49% \u00b1 1.47%\nPeak 5 Percentage is 29.00% \u00b1 1.45%\nPeak 6 Percentage is 3.46% \u00b1 0.73%\nOverall Percentage is 100.00% \u00b1 3.52%\n</code>\n</pre>"},{"location":"user_guide/example_single_peak.html","title":"Example single peak","text":"<p>Import the nmrlineshapeanalyser library</p> <pre><code>import sys\nimport matplotlib.pyplot as plt\nsys.path.append(\"../../src\")\nfrom nmrlineshapeanalyser.core import NMRProcessor\n</code></pre> <p>Create NMRProcessor object</p> <pre><code>processor = NMRProcessor()\n</code></pre> <p>Load filepath</p> <p>nmrlineshapeanalyser supports an already processed Bruker data. It does not support data from any other brand at the moment. You might want to check NMRglue on how to go about that.</p> <p>filepath has the following format: bruker's processed data path (10\\pdata\\1) + \"\\\\\". It is pertinent to leave the \"\\\\\" at the end of the filepath.</p> <pre><code>filepath = r\"..\\..\\data\\single_peak\\10\\pdata\\1\\\\\"\n</code></pre> <p>Load the data</p> <pre><code>processor.load_data(filepath)\n</code></pre> <p>Select the region of interest: (lower_value, higher_value)</p> <pre><code>x_data, y_data = processor.select_region(512, 650)\n</code></pre> <p>Normalize the data and return normalised y_axis and the corresponding x_axis</p> <pre><code>x_data, y_normalized = processor.normalize_data(x_data, y_data)\n</code></pre> <p>define initial parameters for the fitting</p> <p>this example is for a single peak</p> <p>format of the parameters is [x0, amplitude, width, eta, offset]</p> <p>x0 has to be close to the peak position</p> <pre><code>initial_params = [\n581, 0.12, 40.51, 0.89, -1 \n  ]\n</code></pre> <p>fixed_x0 controls whether peak positions should be fixed during fitting</p> <p>False means position can vary, True means position is fixed</p> <pre><code>number_of_peaks = 1\n\nfixed_x0 = [False] * number_of_peaks\n</code></pre> <p>Fit the data</p> <pre><code>popt, metrics, fitted = processor.fit_peaks(x_data, y_normalized, initial_params, fixed_x0)\n</code></pre> <p>popt is the optimized parameters</p> <p>metrics is the metrics of the fitting</p> <p>fitted is the fitted curve data</p> <p>Plot and examine the results of the fitting</p> <pre><code>fig, axes, components = processor.plot_results(x_data, y_normalized, fitted, popt)\n</code></pre> <p>Save the figure as png file and the results as a csv file</p> <pre><code>processor.save_results(filepath, x_data, y_normalized, fitted, metrics, popt, components)\n</code></pre> <pre>\n<code>\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: 582.01 \u00b1 0.01):\nAmplitude: 0.993 \u00b1 0.002\nWidth: 12.33 \u00b1 0.03 in ppm\nWidth: 835.74 \u00b1 2.36 in Hz\nEta: 1.00 \u00b1 0.01\nOffset: -0.004 \u00b1 0.000\nGaussian Area: 0.00 \u00b1 0.10\nLorentzian Area: 19.23 \u00b1 0.16\nTotal Area: 19.23 \u00b1 0.19\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 1.39%\nOverall Percentage is 100.00% \u00b1 1.39%\n</code>\n</pre>"},{"location":"user_guide/hendrickson_bray_lineshape_analysis.html","title":"Hendrickson bray lineshape analysis","text":"<pre><code>import sys\nimport os\nimport matplotlib.pyplot as plt\nsys.path.append(\"../../src\")\nfrom nmrlineshapeanalyser.core import NMRProcessor\nimport nmrglue as ng\nimport numpy as np\nfrom scipy.optimize import curve_fit\nimport matplotlib.pyplot as plt\nimport pandas as pd\n</code></pre> <pre><code>def get_filepaths(directory):\n    \"\"\"Sort directory contents numerically\"\"\"\n    filepaths = os.listdir(directory)\n    filepaths.sort(key=lambda x: int(x))\n    return filepaths\n\ndef get_nmr_paths(directory, filepaths):\n    nmr_paths = []\n    for filename in filepaths:\n        f = os.path.join(directory, filename)\n        nmr_paths.append(os.path.join(f, 'pdata', '1'))\n    return nmr_paths\n\ndef get_larmor_freq(path):\n    dic, data = ng.bruker.read(path)\n    udic = ng.bruker.guess_udic(dic, data)\n    larmor_freq = udic[0]['obs']\n    return larmor_freq\n\ndef process_nmr_data(nmr_paths, processor):\n    widths = []\n    width_errors = []\n    for i, nmr_path in enumerate(nmr_paths):\n        processor.load_data(nmr_path)\n        x_region, y_region = processor.select_region(-500, 500)\n        x_data, y_data = processor.normalize_data(x_region, y_region)\n        initial_params = [-10, 1, 110, 0.5, 100]\n        fixed_x0 = [False]\n        popt, metrics, fitted = processor.fit_peaks(x_data, y_data, initial_params, fixed_x0)\n        fig, axes, components = processor.plot_results(x_data, y_data, fitted, popt)\n        legend = fig.gca().get_legend()\n        legend.set_frame_on(False)\n        fig.set_size_inches(5, 4)\n        path_components = nmr_path.split('\\\\')\n        exp_folder = path_components[path_components.index('pdata') - 1]\n        fig.suptitle(f'nmr folder: {exp_folder}', x=0.75, y=0.95)\n\n        processor.save_results(nmr_path, x_data, y_data, fitted, metrics, popt, components)\n        larmor_freq = get_larmor_freq(nmr_path)\n        width = metrics[0]['width'][0] * larmor_freq / 1000\n        width_error = metrics[0]['width'][1] * larmor_freq / 1000\n        widths.append(width)\n        width_errors.append(width_error)\n    return widths, width_errors\n\nif __name__ == \"__main__\":\n    directory = r'..\\..\\data\\single_peak_HB_analysis\\lineshape'\n    processor = NMRProcessor()\n    filepaths = get_filepaths(directory)\n    nmr_paths = get_nmr_paths(directory, filepaths)\n    widths, width_errors = process_nmr_data(nmr_paths, processor)\n</code></pre> <pre>\n<code>\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -21.00 \u00b1 0.05):\nAmplitude: 1.001 \u00b1 0.001\nWidth: 182.66 \u00b1 0.13 in ppm\nWidth: 85961.80 \u00b1 61.51 in Hz\nEta: 0.13 \u00b1 0.00\nOffset: 0.016 \u00b1 0.000\nGaussian Area: 169.99 \u00b1 0.86\nLorentzian Area: 36.42 \u00b1 1.25\nTotal Area: 206.40 \u00b1 1.52\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 1.04%\nOverall Percentage is 100.00% \u00b1 1.04%\n\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -23.06 \u00b1 0.12):\nAmplitude: 1.010 \u00b1 0.002\nWidth: 181.66 \u00b1 0.36 in ppm\nWidth: 85495.01 \u00b1 168.75 in Hz\nEta: 0.13 \u00b1 0.01\nOffset: 0.014 \u00b1 0.001\nGaussian Area: 170.77 \u00b1 2.38\nLorentzian Area: 36.26 \u00b1 3.44\nTotal Area: 207.03 \u00b1 4.18\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 2.85%\nOverall Percentage is 100.00% \u00b1 2.85%\n\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -22.76 \u00b1 0.04):\nAmplitude: 1.009 \u00b1 0.001\nWidth: 179.69 \u00b1 0.12 in ppm\nWidth: 84564.99 \u00b1 56.90 in Hz\nEta: 0.14 \u00b1 0.00\nOffset: 0.014 \u00b1 0.000\nGaussian Area: 166.08 \u00b1 0.79\nLorentzian Area: 39.62 \u00b1 1.14\nTotal Area: 205.71 \u00b1 1.38\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 0.95%\nOverall Percentage is 100.00% \u00b1 0.95%\n\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -23.76 \u00b1 0.04):\nAmplitude: 1.009 \u00b1 0.001\nWidth: 175.33 \u00b1 0.11 in ppm\nWidth: 82514.48 \u00b1 51.15 in Hz\nEta: 0.17 \u00b1 0.00\nOffset: 0.010 \u00b1 0.000\nGaussian Area: 157.09 \u00b1 0.68\nLorentzian Area: 46.18 \u00b1 0.99\nTotal Area: 203.27 \u00b1 1.20\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 0.84%\nOverall Percentage is 100.00% \u00b1 0.84%\n\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -26.12 \u00b1 0.03):\nAmplitude: 1.000 \u00b1 0.001\nWidth: 169.71 \u00b1 0.10 in ppm\nWidth: 79870.23 \u00b1 47.60 in Hz\nEta: 0.23 \u00b1 0.00\nOffset: 0.012 \u00b1 0.000\nGaussian Area: 139.74 \u00b1 0.59\nLorentzian Area: 60.49 \u00b1 0.86\nTotal Area: 200.23 \u00b1 1.04\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 0.74%\nOverall Percentage is 100.00% \u00b1 0.74%\n\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -24.67 \u00b1 0.02):\nAmplitude: 0.989 \u00b1 0.000\nWidth: 158.86 \u00b1 0.07 in ppm\nWidth: 74760.53 \u00b1 32.71 in Hz\nEta: 0.35 \u00b1 0.00\nOffset: 0.001 \u00b1 0.000\nGaussian Area: 109.41 \u00b1 0.36\nLorentzian Area: 85.39 \u00b1 0.52\nTotal Area: 194.80 \u00b1 0.63\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 0.46%\nOverall Percentage is 100.00% \u00b1 0.46%\n\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -26.37 \u00b1 0.02):\nAmplitude: 0.957 \u00b1 0.000\nWidth: 141.17 \u00b1 0.08 in ppm\nWidth: 66435.62 \u00b1 38.31 in Hz\nEta: 0.56 \u00b1 0.00\nOffset: -0.004 \u00b1 0.000\nGaussian Area: 63.27 \u00b1 0.33\nLorentzian Area: 118.93 \u00b1 0.49\nTotal Area: 182.20 \u00b1 0.59\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 0.46%\nOverall Percentage is 100.00% \u00b1 0.46%\n\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -26.49 \u00b1 0.03):\nAmplitude: 0.946 \u00b1 0.001\nWidth: 107.56 \u00b1 0.12 in ppm\nWidth: 50619.60 \u00b1 55.56 in Hz\nEta: 1.00 \u00b1 0.00\nOffset: -0.008 \u00b1 0.000\nGaussian Area: 0.00 \u00b1 0.33\nLorentzian Area: 159.83 \u00b1 0.53\nTotal Area: 159.83 \u00b1 0.63\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 0.56%\nOverall Percentage is 100.00% \u00b1 0.56%\n\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -25.93 \u00b1 0.03):\nAmplitude: 0.915 \u00b1 0.001\nWidth: 78.52 \u00b1 0.11 in ppm\nWidth: 36952.62 \u00b1 52.45 in Hz\nEta: 1.00 \u00b1 0.00\nOffset: 0.001 \u00b1 0.000\nGaussian Area: 0.00 \u00b1 0.29\nLorentzian Area: 112.88 \u00b1 0.47\nTotal Area: 112.88 \u00b1 0.55\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 0.69%\nOverall Percentage is 100.00% \u00b1 0.69%\n\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -27.19 \u00b1 0.02):\nAmplitude: 0.919 \u00b1 0.001\nWidth: 52.66 \u00b1 0.09 in ppm\nWidth: 24780.67 \u00b1 41.03 in Hz\nEta: 1.00 \u00b1 0.00\nOffset: 0.008 \u00b1 0.000\nGaussian Area: 0.00 \u00b1 0.22\nLorentzian Area: 76.00 \u00b1 0.35\nTotal Area: 76.00 \u00b1 0.41\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 0.77%\nOverall Percentage is 100.00% \u00b1 0.77%\n\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -27.34 \u00b1 0.01):\nAmplitude: 0.949 \u00b1 0.001\nWidth: 35.64 \u00b1 0.05 in ppm\nWidth: 16773.96 \u00b1 23.21 in Hz\nEta: 1.00 \u00b1 0.00\nOffset: 0.008 \u00b1 0.000\nGaussian Area: 0.00 \u00b1 0.12\nLorentzian Area: 53.13 \u00b1 0.20\nTotal Area: 53.13 \u00b1 0.24\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 0.63%\nOverall Percentage is 100.00% \u00b1 0.63%\n\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -27.77 \u00b1 0.01):\nAmplitude: 0.979 \u00b1 0.001\nWidth: 25.35 \u00b1 0.02 in ppm\nWidth: 11929.97 \u00b1 11.49 in Hz\nEta: 1.00 \u00b1 0.00\nOffset: 0.005 \u00b1 0.000\nGaussian Area: 0.00 \u00b1 0.06\nLorentzian Area: 38.98 \u00b1 0.10\nTotal Area: 38.98 \u00b1 0.12\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 0.43%\nOverall Percentage is 100.00% \u00b1 0.43%\n\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -27.40 \u00b1 0.00):\nAmplitude: 1.002 \u00b1 0.000\nWidth: 18.95 \u00b1 0.01 in ppm\nWidth: 8917.42 \u00b1 3.96 in Hz\nEta: 1.00 \u00b1 0.00\nOffset: 0.003 \u00b1 0.000\nGaussian Area: 0.00 \u00b1 0.02\nLorentzian Area: 29.82 \u00b1 0.04\nTotal Area: 29.82 \u00b1 0.04\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 0.20%\nOverall Percentage is 100.00% \u00b1 0.20%\n\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -27.51 \u00b1 0.00):\nAmplitude: 1.001 \u00b1 0.000\nWidth: 15.30 \u00b1 0.01 in ppm\nWidth: 7200.74 \u00b1 3.34 in Hz\nEta: 0.83 \u00b1 0.00\nOffset: 0.002 \u00b1 0.000\nGaussian Area: 2.69 \u00b1 0.02\nLorentzian Area: 20.08 \u00b1 0.03\nTotal Area: 22.77 \u00b1 0.04\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 0.22%\nOverall Percentage is 100.00% \u00b1 0.22%\n\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -27.98 \u00b1 0.00):\nAmplitude: 1.000 \u00b1 0.000\nWidth: 12.54 \u00b1 0.00 in ppm\nWidth: 5902.67 \u00b1 1.37 in Hz\nEta: 0.70 \u00b1 0.00\nOffset: 0.001 \u00b1 0.000\nGaussian Area: 3.96 \u00b1 0.01\nLorentzian Area: 13.86 \u00b1 0.01\nTotal Area: 17.82 \u00b1 0.01\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 0.12%\nOverall Percentage is 100.00% \u00b1 0.12%\n\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -28.11 \u00b1 0.00):\nAmplitude: 0.999 \u00b1 0.000\nWidth: 10.48 \u00b1 0.00 in ppm\nWidth: 4933.16 \u00b1 1.13 in Hz\nEta: 0.58 \u00b1 0.00\nOffset: 0.001 \u00b1 0.000\nGaussian Area: 4.65 \u00b1 0.01\nLorentzian Area: 9.59 \u00b1 0.01\nTotal Area: 14.24 \u00b1 0.01\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 0.13%\nOverall Percentage is 100.00% \u00b1 0.13%\n\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -28.08 \u00b1 0.00):\nAmplitude: 0.998 \u00b1 0.000\nWidth: 9.03 \u00b1 0.00 in ppm\nWidth: 4251.81 \u00b1 0.83 in Hz\nEta: 0.47 \u00b1 0.00\nOffset: 0.001 \u00b1 0.000\nGaussian Area: 5.05 \u00b1 0.01\nLorentzian Area: 6.72 \u00b1 0.01\nTotal Area: 11.77 \u00b1 0.01\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 0.11%\nOverall Percentage is 100.00% \u00b1 0.11%\n\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -27.92 \u00b1 0.00):\nAmplitude: 0.996 \u00b1 0.000\nWidth: 8.04 \u00b1 0.00 in ppm\nWidth: 3785.87 \u00b1 0.71 in Hz\nEta: 0.39 \u00b1 0.00\nOffset: 0.001 \u00b1 0.000\nGaussian Area: 5.20 \u00b1 0.00\nLorentzian Area: 4.91 \u00b1 0.01\nTotal Area: 10.11 \u00b1 0.01\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 0.12%\nOverall Percentage is 100.00% \u00b1 0.12%\n\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -27.68 \u00b1 0.00):\nAmplitude: 0.991 \u00b1 0.000\nWidth: 7.34 \u00b1 0.00 in ppm\nWidth: 3452.30 \u00b1 0.87 in Hz\nEta: 0.33 \u00b1 0.00\nOffset: 0.001 \u00b1 0.000\nGaussian Area: 5.15 \u00b1 0.01\nLorentzian Area: 3.82 \u00b1 0.01\nTotal Area: 8.97 \u00b1 0.01\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 0.16%\nOverall Percentage is 100.00% \u00b1 0.16%\n</code>\n</pre> <pre>\n<code>c:\\Users\\babdulkadirola\\AppData\\Local\\mambaforge\\envs\\miniconda\\lib\\site-packages\\nmrlineshapeanalyser\\core.py:448: RuntimeWarning: More than 20 figures have been opened. Figures created through the pyplot interface (`matplotlib.pyplot.figure`) are retained until explicitly closed and may consume too much memory. (To control this warning, see the rcParam `figure.max_open_warning`). Consider using `matplotlib.pyplot.close()`.\n  fig, ax1 = plt.subplots(1, 1, figsize=(12, 10))\n</code>\n</pre> <pre>\n<code>\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -27.44 \u00b1 0.00):\nAmplitude: 0.986 \u00b1 0.000\nWidth: 6.90 \u00b1 0.00 in ppm\nWidth: 3246.72 \u00b1 1.05 in Hz\nEta: 0.31 \u00b1 0.00\nOffset: 0.001 \u00b1 0.000\nGaussian Area: 5.01 \u00b1 0.01\nLorentzian Area: 3.29 \u00b1 0.01\nTotal Area: 8.30 \u00b1 0.01\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 0.21%\nOverall Percentage is 100.00% \u00b1 0.21%\n</code>\n</pre> <pre>\n<code>c:\\Users\\babdulkadirola\\AppData\\Local\\mambaforge\\envs\\miniconda\\lib\\site-packages\\nmrlineshapeanalyser\\core.py:448: RuntimeWarning: More than 20 figures have been opened. Figures created through the pyplot interface (`matplotlib.pyplot.figure`) are retained until explicitly closed and may consume too much memory. (To control this warning, see the rcParam `figure.max_open_warning`). Consider using `matplotlib.pyplot.close()`.\n  fig, ax1 = plt.subplots(1, 1, figsize=(12, 10))\n</code>\n</pre> <pre>\n<code>\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: -27.18 \u00b1 0.00):\nAmplitude: 0.983 \u00b1 0.000\nWidth: 6.63 \u00b1 0.00 in ppm\nWidth: 3119.50 \u00b1 1.28 in Hz\nEta: 0.29 \u00b1 0.00\nOffset: 0.001 \u00b1 0.000\nGaussian Area: 4.89 \u00b1 0.01\nLorentzian Area: 3.02 \u00b1 0.01\nTotal Area: 7.90 \u00b1 0.02\n--------------------------------------------------\nPeak 1 Percentage is 100.00% \u00b1 0.27%\nOverall Percentage is 100.00% \u00b1 0.27%\n</code>\n</pre> <p>x data, which is the temperature in Kelvin, can be created using linspace function from numpy. Where the first argument is the starting temperature in Celsius, the second argument is the ending temperature in Celsius,  and the third argument is the number of points to be generated between the starting and ending temperatures (which is the length of the widths/filepaths).</p> <pre><code>x_data = np.linspace(-80, 120, len(widths))\n\nx_data = x_data + 273.15\n\n# print(x_data)\n</code></pre> <p>Also, the Temperature  in Kelvin can be pre-stored in a csv file such that each filepath in filepaths corresponds to an NMR experimental number and the corresponding temperature in Kelvin. So you have to create a csv file (named: temperature_points.csv) with two columns: column 1 is the filepath and column 2 is the temperature in Kelvin. The csv file should be stored in the same directory as the lineshape folder</p> <pre><code># parent = os.path.dirname(directory)\n\n# csv_path = os.path.join(parent, 'temperature_points.csv')\n\n# df = pd.read_csv(csv_path, sep='\\t', header=None)\n\n# x_data = df[1]\n\n# print(df.head(25))\n</code></pre> <pre><code>lineshape_data = pd.DataFrame({'Exp. no.': filepaths, 'Temperature (K)': x_data, \n\n                    'Widths (kHz)': widths, 'Widths Error (kHz)': width_errors})\n\nprint(lineshape_data)\n</code></pre> <pre>\n<code>   Exp. no.  Temperature (K)  Widths (kHz)  Widths Error (kHz)\n0         1           193.15     85.961803            0.061512\n1         3           203.15     85.495006            0.168749\n2         4           213.15     84.564987            0.056896\n3         6           223.15     82.514484            0.051145\n4         8           233.15     79.870233            0.047599\n5        10           243.15     74.760528            0.032712\n6        12           253.15     66.435620            0.038308\n7        14           263.15     50.619596            0.055557\n8        16           273.15     36.952618            0.052455\n9        18           283.15     24.780674            0.041032\n10       20           293.15     16.773963            0.023206\n11       22           303.15     11.929973            0.011493\n12       24           313.15      8.917421            0.003964\n13       26           323.15      7.200743            0.003337\n14       28           333.15      5.902666            0.001366\n15       30           343.15      4.933160            0.001128\n16       32           353.15      4.251806            0.000830\n17       34           363.15      3.785870            0.000711\n18       36           373.15      3.452299            0.000868\n19       38           383.15      3.246723            0.001051\n20       40           393.15      3.119499            0.001282\n</code>\n</pre> <pre><code>def HB_equation (x_data, B, Ea, A, D):\n    k = 8.62*10**-5\n    return (A / (1 + ((A / B) - 1) * np.exp(-Ea / (k * x_data)))) + D\n\ndef HB_analysis (x_data, y_data, y_error, initial_guesses, file_name):\n\n    #initial guesses should be written as [B_guess, Ea_guess, A_guess, D_guess]\n\n    #if u guess wrong, the fit would misbehave. try another guess values if such happens\n\n    #x_data should be in Kelvin #y_data should be in kHz : that is the imported data\n\n    k = 8.61733034e-5 #to be expressed in eV\n\n    #now, we are defining the HB equation\n\n\n    #now we have to run the fitting\n\n    popt, pcov = curve_fit(HB_equation, x_data, y_data, p0=initial_guesses, maxfev=5000)\n\n\n    #storing the optimised parameters in a tag\n\n    B_opt, Ea_opt, A_opt, D_opt = popt\n\n    #the diagonal of pcov contains the error of each parameter\n\n    perr = np.sqrt(np.diag(pcov))\n\n    #store the respective errors in a tag\n\n    B_err, Ea_err, A_err, D_err = perr\n\n    # determining the quality of the fit\n\n    ##predict the model, the HB model, using the optimized parameters\n    #x_fit = np.linspace(np.min(x_data), np.max(x_data), 1000) #would affect determination of r2\n    y_fit = HB_equation(x_data, B_opt, Ea_opt, A_opt, D_opt)\n\n    ##predicting the r square\n\n    squaredDiffs = np.square(y_data - y_fit)\n\n    squaredDiffsFromMean = np.square(y_data - np.mean(y_data))\n\n    rsquared = 1 - np.sum(squaredDiffs)/np.sum(squaredDiffsFromMean)\n\n    print(f\"R\u00b2 = {rsquared}\")\n\n    #Plotting the results\n\n    #_____________________________________________________________________________#\n\n\n\n    # inspect the parameters\n    print(f\"w = [{A_opt} / 1 + ({A_opt}/{B_opt} - 1) * e^(-{Ea_opt}/k*T)] + {D_opt}\")\n\n    #print the errors\n\n    perr = np.sqrt(np.diag(pcov))\n\n    #store the respective errors in a tag\n\n    B_err, Ea_err, A_err, D_err = perr\n\n    #print the optimised variables and their errors\n\n    print('B:', f'{B_opt} +/- {B_err}')\n\n    print('Ea:', f'{Ea_opt} +/- {Ea_err}')\n\n    print('A:', f'{A_opt} +/- {A_err}')\n\n    print('D:', f'{D_opt} +/- {D_err}')\n\n    params_data = pd.DataFrame({'Parameters': ['B', 'Ea', 'A', 'D'],\n                                'Values': [B_opt, Ea_opt, A_opt, D_opt], 'Errors': [B_err, Ea_err, A_err, D_err]})\n\n\n\n    params_data.to_csv(file_name+'HB_parameters.csv')\n\n\n    return y_fit, Ea_opt, Ea_err, B_opt, A_opt, D_opt\n</code></pre> <pre><code>y_fit, _, _, _, _, _= HB_analysis(x_data, widths, width_errors, [1e-7, 0.6, 45, 3], directory)\n\n#Initual guess values: [B_guess, Ea_guess, A_guess, D_guess] == [1e-7, 0.6, 45, 3]; change these based on your system\n</code></pre> <pre>\n<code>R\u00b2 = 0.999705047871229\nw = [81.91524646792928 / 1 + (81.91524646792928/5.582261696551946e-07 - 1) * e^(-0.43431741346508856/k*T)] + 3.3891625803320578\nB: 5.582261696551946e-07 +/- 2.017347895654216e-07\nEa: 0.43431741346508856 +/- 0.008295485984395043\nA: 81.91524646792928 +/- 0.46374683606992884\nD: 3.3891625803320578 +/- 0.26439736857916435\n</code>\n</pre> <pre><code>#You can add the results to the lineshape_data dataframe\n\nlineshape_data['widths_fit (kHz)'] = y_fit\n\nprint(lineshape_data)\n</code></pre> <pre>\n<code>   Exp. no.  Temperature (K)  Widths (kHz)  Widths Error (kHz)  \\\n0         1           193.15     85.961803            0.061512   \n1         3           203.15     85.495006            0.168749   \n2         4           213.15     84.564987            0.056896   \n3         6           223.15     82.514484            0.051145   \n4         8           233.15     79.870233            0.047599   \n5        10           243.15     74.760528            0.032712   \n6        12           253.15     66.435620            0.038308   \n7        14           263.15     50.619596            0.055557   \n8        16           273.15     36.952618            0.052455   \n9        18           283.15     24.780674            0.041032   \n10       20           293.15     16.773963            0.023206   \n11       22           303.15     11.929973            0.011493   \n12       24           313.15      8.917421            0.003964   \n13       26           323.15      7.200743            0.003337   \n14       28           333.15      5.902666            0.001366   \n15       30           343.15      4.933160            0.001128   \n16       32           353.15      4.251806            0.000830   \n17       34           363.15      3.785870            0.000711   \n18       36           373.15      3.452299            0.000868   \n19       38           383.15      3.246723            0.001051   \n20       40           393.15      3.119499            0.001282   \n\n    widths_fit (kHz)  \n0          85.248088  \n1          85.101380  \n2          84.657962  \n3          83.467155  \n4          80.636496  \n5          74.808001  \n6          64.831148  \n7          51.295612  \n8          37.086086  \n9          25.262342  \n10         16.958252  \n11         11.680556  \n12          8.477990  \n13          6.559418  \n14          5.403664  \n15          4.697088  \n16          4.256884  \n17          3.976995  \n18          3.795367  \n19          3.675142  \n20          3.594044  \n</code>\n</pre> <pre><code>plt.errorbar(x_data, widths, yerr=width_errors, fmt='o', label= 'Widths')\n\nplt.plot(x_data, y_fit, label='HB Fit')\n\nplt.legend()\n\nplt.xlabel('Temperature (K)')\n\nplt.ylabel('FWHM (kHz)')\n</code></pre> <pre>\n<code>Text(0, 0.5, 'FWHM (kHz)')</code>\n</pre> <p>If the visualisation of the fit and optimsed parameters are satisfactory, you can save the lineshape_data dataframe to a csv file just in case you would like to visualise the data in your preferred software</p> <pre><code>lineshape_data.to_csv(directory+'lineshape_data.csv')\n</code></pre>"},{"location":"user_guide/hendrickson_bray_lineshape_analysis.html#hendrickson-bray-motional-narrowing-analysis-processing-pipeline","title":"Hendrickson-Bray motional narrowing analysis processing pipeline","text":"<p>This script processes data by: 1. Reading Bruker format NMR data files 2. Fitting peaks and analyzing lineshapes 3. Calculating widths and errors normalized to Larmor frequency 4. Plotting calculated widths vs temperature 5. Fitting Hendrickson-Bray model to data 6. Exporting the fitted parameters to a CSV file 7. Plotting the data and fitted model</p> <p>Functions:</p> <pre><code>   get_filepaths(directory): Lists and sorts files in directory by integer value\n\n   get_nmr_paths(directory, filepaths): Constructs full paths to NMR data files\n\n   get_larmor_freq(path): Extracts Larmor frequency from Bruker data dictionary\n\n   process_nmr_data(nmr_paths, processor): Main processing pipeline that:\n       - Loads NMR data\n       - Selects region of interest (-500 to 500 ppm)\n       - Normalizes data\n       - Fits peaks with given initial parameters -- this is an important step, \n            as the initial parameters are crucial for the fitting process. If you have multiple peaks, that is another story.\n            Anyway, ensure that the first initial parameters are that of the peak that correlates to the atomic site of interest.\n       - Plots and saves results\n       - Calculates widths normalized to Larmor frequency\n</code></pre>"},{"location":"user_guide/working_with_a_csv_file.html","title":"Working with a csv file","text":"<pre><code>import sys\nimport glob\nimport os\nimport matplotlib.pyplot as plt\nsys.path.append(\"../../src\")\nfrom nmrlineshapeanalyser.core import NMRProcessor\n\nimport pandas as pd\n</code></pre> <pre><code># Initialize processor\nprocessor = NMRProcessor()\n\n\nfilepath = r\"..\\..\\data\\data_saved_in_csv\"\n</code></pre> <p>The CSV file must have the following columns:</p> <pre><code>csv_file = glob.glob(os.path.join(filepath, \"*.csv\"))\n\nprint(csv_file)\ndf = pd.read_csv(csv_file[0])\ndf = df[['ppm', 'Intensity']]\n\ndf.head(5)\n</code></pre> <pre>\n<code>['..\\\\..\\\\data\\\\data_saved_in_csv\\\\spectrum_peak.csv']\n</code>\n</pre> ppm Intensity 0 10547.8 -15.0 1 10546.6 -15.0 2 10545.4 -15.0 3 10544.1 -15.0 4 10542.9 -15.0 <pre><code># Load data\nprocessor.load_csv(filepath, '17', 'O', 67.8)   \n\n# Select region and normalize\nx_region, y_region = processor.select_region(160, 850)\nx_data, y_normalized = processor.normalize_data(x_region, y_region)\n\n# Define initial parameters for peaks\n# Each peak is defined by 5 parameters in order:\n# x0 (position), amplitude, width, eta (mixing parameter), offset\ninitial_params = [\n    348, 0.16, 81, 0.89, -143.115, \n\n    435.5, 0.29, 51, 0.89, -143.115,\n\n    560, 0.52, 100, 0.52, -1,\n\n    600, 0.61, 82, 0.52, -1,\n\n]\n\n# Fit peaks\n# fixed_x0 controls whether peak positions should be fixed during fitting\n# False means position can vary, True means position is fixed\nfixed_x0 = [False, False, False, True] # Allow all peak positions to vary\n# popt: optimized parameters\n# metrics: fitting metrics for each peak\n# fitted: fitted curve data\npopt, metrics, fitted = processor.fit_peaks(x_data, y_normalized, initial_params, fixed_x0)\n\n# Plot and save results\nfig, axes, components = processor.plot_results(x_data, y_normalized, fitted, popt)\n\n# Save all results\nprocessor.save_results(filepath, x_data, y_normalized, fitted, metrics, \n                        popt, components)\n</code></pre> <pre>\n<code>\nPeak Fitting Results:\n===================\n\nPeak 1 (Position: 343.04 \u00b1 5.76):\nAmplitude: 0.119 \u00b1 0.029\nWidth: 83.74 \u00b1 11.29 in ppm\nWidth: 5677.57 \u00b1 765.29 in Hz\nEta: 0.22 \u00b1 0.25\nOffset: 281.765 \u00b1 1046.103\nGaussian Area: 8.26 \u00b1 3.51\nLorentzian Area: 3.43 \u00b1 4.01\nTotal Area: 11.69 \u00b1 5.33\n--------------------------------------------------\n\nPeak 2 (Position: 432.92 \u00b1 0.64):\nAmplitude: 0.338 \u00b1 0.028\nWidth: 68.71 \u00b1 9.27 in ppm\nWidth: 4658.72 \u00b1 628.44 in Hz\nEta: 1.00 \u00b1 0.46\nOffset: 41298.781 \u00b1 624599.253\nGaussian Area: 0.00 \u00b1 11.34\nLorentzian Area: 36.48 \u00b1 17.70\nTotal Area: 36.48 \u00b1 21.02\n--------------------------------------------------\n\nPeak 3 (Position: 551.42 \u00b1 4.41):\nAmplitude: 0.612 \u00b1 0.062\nWidth: 110.12 \u00b1 10.66 in ppm\nWidth: 7466.17 \u00b1 722.60 in Hz\nEta: 0.06 \u00b1 0.11\nOffset: -9104.947 \u00b1 46579.511\nGaussian Area: 67.63 \u00b1 12.51\nLorentzian Area: 5.98 \u00b1 12.01\nTotal Area: 73.62 \u00b1 17.34\n--------------------------------------------------\n\nPeak 4 (Position: 600.00 \u00b1 0.00):\nAmplitude: 0.511 \u00b1 0.099\nWidth: 92.34 \u00b1 1.90 in ppm\nWidth: 6260.69 \u00b1 128.49 in Hz\nEta: 0.00 \u00b1 0.07\nOffset: -32475.588 \u00b1 625950.358\nGaussian Area: 50.21 \u00b1 10.35\nLorentzian Area: 0.00 \u00b1 5.07\nTotal Area: 50.21 \u00b1 11.52\n--------------------------------------------------\nPeak 1 Percentage is 6.80% \u00b1 3.32%\nPeak 2 Percentage is 21.21% \u00b1 12.77%\nPeak 3 Percentage is 42.80% \u00b1 12.55%\nPeak 4 Percentage is 29.19% \u00b1 8.42%\nOverall Percentage is 100.00% \u00b1 20.07%\n</code>\n</pre>"},{"location":"user_guide/working_with_a_csv_file.html#work-with-spectrum-data-saved-in-a-csv-file","title":"Work with spectrum data saved in a csv file","text":"<p>The load_csv function lets you work directly with NMR data saved in a csv file.filter</p> <p>Important thing to know is that this function, unlike the load_data function that works directly with Bruker files, you would have to declare the following parameters alongside the file path:</p> <pre><code>    - nucleus: the nucleus of the spectrum i.e. H, C, F, P, etc.\n    - atomic number: the atomic number of the nucleus\n    - larmor frequency: the frequency of the nucleus with respect to the magnetic field B0 in MHz\n</code></pre>"}]}